import { ref } from 'vue'

// Reserved SQL keywords that shouldn't be used as column names or table names
export const reservedKeywords = [
  'add',
  'all',
  'alter',
  'and',
  'any',
  'as',
  'asc',
  'backup',
  'between',
  'case',
  'check',
  'column',
  'constraint',
  'create',
  'database',
  'default',
  'delete',
  'desc',
  'distinct',
  'drop',
  'exec',
  'exists',
  'foreign',
  'from',
  'full',
  'group',
  'having',
  'in',
  'index',
  'inner',
  'insert',
  'is',
  'join',
  'key',
  'left',
  'like',
  'limit',
  'not',
  'null',
  'or',
  'order',
  'outer',
  'primary',
  'procedure',
  'right',
  'rownum',
  'select',
  'set',
  'table',
  'top',
  'truncate',
  'union',
  'unique',
  'update',
  'values',
  'view',
  'where',
]

// MySQL column types
export const mysqlColumnTypes = ref<string[]>([
  // Numeric
  'TINYINT',
  'SMALLINT',
  'MEDIUMINT',
  'INT', // aka INTEGER
  'BIGINT',

  // Exact‐value numbers
  'DECIMAL',
  'FLOAT',
  'DOUBLE',
  'BIT',
  'BOOLEAN', // alias for TINYINT(1)

  // String & binary
  'CHAR',
  'VARCHAR',
  'BINARY',
  'VARBINARY',

  // Blobs & texts
  'TINYBLOB',
  'BLOB',
  'MEDIUMBLOB',
  'LONGBLOB',
  'TINYTEXT',
  'TEXT',
  'MEDIUMTEXT',
  'LONGTEXT',

  // Enumerations
  'ENUM',
  'SET',

  // Date & time
  'DATE',
  'TIME',
  'DATETIME',
  'TIMESTAMP',
  'YEAR',

  // JSON
  'JSON',

  // Spatial (if you have MySQL GIS)
  'GEOMETRY',
  'POINT',
  'LINESTRING',
  'POLYGON',
  'MULTIPOINT',
  'MULTILINESTRING',
  'MULTIPOLYGON',
  'GEOMETRYCOLLECTION',
])

// SQLite column types
export const sqliteColumnTypes = ref<string[]>([
  'BIGINT', // → maps to INTEGER
  'CHARACTER(20)', // → maps to TEXT
  'CLOB', // → maps to TEXT
  'DATE', // → maps to TEXT
  'DATETIME', // → maps to TEXT
  'DECIMAL', // → maps to NUMERIC
  'DOUBLE', // → maps to REAL
  'DOUBLE PRECISION', // → maps to REAL
  'FLOAT', // → maps to REAL
  'INT', // → maps to INTEGER
  'MEDIUMINT', // → maps to INTEGER
  'NCHAR(55)', // → maps to TEXT
  'NATIVE CHARACTER(70)', // → maps to TEXT
  'NVARCHAR(100)', // → maps to TEXT
  'SMALLINT', // → maps to INTEGER
  'TINYINT', // → maps to INTEGER
  'UNSIGNED BIG INT', // → maps to INTEGER
  'VARBINARY', // → maps to BLOB
  'VARCHAR(255)', // → maps to TEXT
  'VARYING CHARACTER(255)', // → maps to TEXT
  'BOOLEAN', // → maps to NUMERIC (0/1)
])

// PostgreSQL column types
export const pgColumnTypes = ref<string[]>([
  // Numeric
  'SMALLINT',
  'INTEGER',
  'BIGINT',
  'DECIMAL', // exact precision
  'NUMERIC', // alias for DECIMAL
  'REAL', // 4-byte float
  'DOUBLE PRECISION', // 8-byte float
  'SMALLSERIAL',
  'SERIAL',
  'BIGSERIAL',
  'MONEY',

  // Character
  'CHAR', // fixed‐length
  'VARCHAR', // variable‐length
  'TEXT', // unlimited
  'CHARACTER', // synonym for CHAR
  'CHARACTER VARYING', // synonym for VARCHAR

  // Binary
  'BYTEA', // binary data ("BLOB" in PG)

  // Date & Time
  'DATE',
  'TIME', // without time zone
  'TIMETZ', // with time zone
  'TIMESTAMP', // without time zone
  'TIMESTAMPTZ', // with time zone
  'INTERVAL', // time spans

  // Boolean
  'BOOLEAN',

  // UUID
  'UUID',

  // JSON
  'JSON',
  'JSONB', // binary-storage JSON

  // XML
  'XML',

  // Network
  'CIDR',
  'INET',
  'MACADDR',
  'MACADDR8',

  // Geometric
  'POINT',
  'LINE',
  'LSEG',
  'BOX',
  'PATH',
  'POLYGON',
  'CIRCLE',

  // Range types
  'INT4RANGE',
  'INT8RANGE',
  'NUMRANGE',
  'TSRANGE',
  'TSTZRANGE',
  'DATERANGE',
])

// Auto-increment type definitions for different database engines
export const mysqlAutoIncrementTypes = ref<string[]>([
  'TINYINT',
  'SMALLINT',
  'MEDIUMINT',
  'INT',
  'BIGINT',
])

export const postgresAutoIncrementTypes = ref<string[]>(['SMALLSERIAL', 'SERIAL', 'BIGSERIAL'])

export const sqliteAutoIncrementTypes = ref<string[]>(['INTEGER'])

// Auto-increment value definitions for different database engines when creating request object
export const mysqlAutoIncrementValues = ref<string[]>(['AUTO_INCREMENT'])

export const postgresAutoIncrementValues = ref<string[]>([
  'GENERATED ALWAYS AS IDENTITY',
  'GENERATED BY DEFAULT AS IDENTITY',
])

export const sqliteAutoIncrementValues = ref<string[]>(['AUTOINCREMENT'])

// The active column types list - this will be set dynamically based on database engine
export const columnTypes = ref<string[]>([...mysqlColumnTypes.value]) // Default to MySQL column types

// Track the current database engine
export const currentDbEngine = ref<string>('mysql')

// Function to load environment configuration
export async function loadEnv(): Promise<any> {
  try {
    // Fetch environment configuration from env.json
    const response = await fetch('/env.json')
    if (!response.ok) {
      console.error('Failed to load environment configuration')
      return { dbEngine: 'mysql' } // Default fallback
    }
    return await response.json()
  } catch (error) {
    console.error('Error loading environment configuration:', error)
    return { dbEngine: 'mysql' } // Default fallback
  }
}

// Helper to determine if a column type can be auto-incremented based on the database engine
export function canAutoIncrement(type: string): boolean {
  // Convert to uppercase for case-insensitive comparison
  const upperType = type.toUpperCase()

  // Check against the appropriate list based on the database engine
  if (currentDbEngine.value === 'sqlite') {
    return sqliteAutoIncrementTypes.value.some((t) => upperType === t)
  } else if (
    currentDbEngine.value === 'postgres' ||
    currentDbEngine.value === 'postgresql' ||
    currentDbEngine.value === 'pg'
  ) {
    return postgresAutoIncrementTypes.value.some((t) => upperType === t)
  } else {
    // Default to MySQL
    return mysqlAutoIncrementTypes.value.some((t) => upperType === t)
  }
}

// Get the appropriate auto-increment syntax based on database engine
export function getAutoIncrementValue(): string {
  if (currentDbEngine.value === 'sqlite') {
    return sqliteAutoIncrementValues.value[0]
  } else if (
    currentDbEngine.value === 'postgres' ||
    currentDbEngine.value === 'postgresql' ||
    currentDbEngine.value === 'pg'
  ) {
    // For PostgreSQL, using the first option by default: GENERATED ALWAYS AS IDENTITY
    return postgresAutoIncrementValues.value[0]
  } else {
    // Default to MySQL
    return mysqlAutoIncrementValues.value[0]
  }
}

loadEnv().then((env) => {
  const dbEngine = env.dbEngine?.toLowerCase() || 'mysql'
  currentDbEngine.value = dbEngine

  // Update the columnTypes reactive reference based on dbEngine
  if (dbEngine === 'sqlite') {
    columnTypes.value = sqliteColumnTypes.value
  } else if (dbEngine === 'postgres' || dbEngine === 'postgresql' || dbEngine === 'pg') {
    columnTypes.value = pgColumnTypes.value
  } else {
    // Default to MySQL
    columnTypes.value = mysqlColumnTypes.value
  }

  console.log(`Database engine detected: ${dbEngine}`)
})

// Format a database name to follow naming conventions (replace spaces with underscores, etc.)
export function formatDatabaseName(name: string): string {
  // Replace spaces with underscores
  let formatted = name.replace(/\s+/g, '_')

  // Remove special characters except underscores
  formatted = formatted.replace(/[^a-zA-Z0-9_]/g, '')

  // Ensure it starts with a letter or underscore
  if (formatted && !/^[a-zA-Z_]/.test(formatted)) {
    formatted = '_' + formatted
  }

  return formatted
}

// Helper to determine if a column type needs length specification
export function needsLength(type: string): boolean {
  // Convert to uppercase for case-insensitive comparison
  const upperType = type.toUpperCase()

  // Common types that need length specification across database engines
  const typesNeedingLength = [
    // String types
    'VARCHAR',
    'CHAR',
    'CHARACTER',
    'CHARACTER VARYING',
    'NVARCHAR',
    'NCHAR',
    'NATIVE CHARACTER',
    'VARYING CHARACTER',

    // Binary types
    'BINARY',
    'VARBINARY',

    // Numeric types with precision/scale
    'DECIMAL',
    'NUMERIC',
    'FLOAT',
    'DOUBLE',
    'DOUBLE PRECISION',
    'REAL',

    // Integer types that sometimes accept length
    'INT',
    'INTEGER',
    'TINYINT',
    'SMALLINT',
    'MEDIUMINT',
    'BIGINT',

    // Some database-specific types
    'BIT',
  ]

  return typesNeedingLength.includes(upperType)
}
